
int find(int parent[], int i) {
// Write your code here..
 if (parent[i] != i)
        parent[i] = find(parent, parent[i]);
    return parent[i];
}


void union1(int parent[], int rank[], int i, int j) {
int xroot = find(parent, i);
    int yroot = find(parent, j);

    if (rank[xroot] < rank[yroot])
        parent[xroot] = yroot;
    else if (rank[xroot] > rank[yroot])
        parent[yroot] = xroot;
    else {
        parent[yroot] = xroot;
        rank[xroot]++;
	}
	// Write your code here...
}
typedef struct {
    int u, v, cost;
} Edge;

void kruskalMST(int **cost, int V) {

	// Write your code here...
  Edge *edges = (Edge *)malloc(V * V * sizeof(Edge));
    int edgeCount = 0;

    // Extract all edges from upper triangle (avoid duplicates)
    for (int i = 0; i < V; i++) {
        for (int j = i + 1; j < V; j++) {
            if (cost[i][j] != 9999) {
                edges[edgeCount].u = i;
                edges[edgeCount].v = j;
                edges[edgeCount].cost = cost[i][j];
                edgeCount++;
            }
    }
}


    // Sort edges by cost (Bubble Sort for simplicity)
    for (int i = 0; i < edgeCount - 1; i++) {
        for (int j = 0; j < edgeCount - i - 1; j++) {
            if (edges[j].cost > edges[j + 1].cost) {
                Edge temp = edges[j];
                edges[j] = edges[j + 1];
                edges[j + 1] = temp;
            }
        }
    }

    int *parent = (int *)malloc(V * sizeof(int));
    int *rank = (int *)malloc(V * sizeof(int));

    for (int i = 0; i < V; i++) {
        parent[i] = i;
        rank[i] = 0;
    }

    int edgeNum = 0;
    int totalCost = 0;
    int mstEdges = 0;

    while (mstEdges < V - 1 && edgeNum < edgeCount) {
        Edge current = edges[edgeNum++];
        int x = find(parent, current.u);
        int y = find(parent, current.v);

        if (x != y) {
            printf("Edge %d:(%d, %d) cost:%d\n", mstEdges, current.u, current.v, current.cost);
            totalCost += current.cost;
            union1(parent, rank, x, y);
            mstEdges++;
        }
    }

    printf("Minimum cost= %d\n", totalCost);

    free(edges);
    free(parent);
    free(rank);
}


int main() {
    int V;
    printf("No of vertices: ");
    scanf("%d", &V);

    int **cost = (int **)malloc(V * sizeof(int *));
    for (int i = 0; i < V; i++)
        cost[i] = (int *)malloc(V * sizeof(int));

    printf("Adjacency matrix:\n");
    for (int i = 0; i < V; i++)
        for (int j = 0; j < V; j++)
            scanf("%d", &cost[i][j]);

    kruskalMST(cost, V);

    for (int i = 0; i < V; i++)
        free(cost[i]);
    free(cost);

    return 0;
}
